<!doctype html>
<html>
<link rel='stylesheet' href='innote.bootstrap.css'>
<link rel='stylesheet' href='innote.export.css'>
<link rel='stylesheet' href='custom.css'><!-- add your own, export doesn't contain it -->
<style>
</style>
<body><!-- {"id":"1194","code":"overview","title":"Docs ::   Overview","project":"scriptonit"} -->
<div class='article-contents' style='margin:auto;max-width:1200px;padding:40px;'>


            <div class="title"> 

                <span class="title-group" data-group="docs"> ScriptOnIt / Docs </span>
                <span class="title-text"> Overview </span>

             </div>
            <div class="body"> <div style='margin-bottom:-40px;'></div>
<h2>What's this all about?  <style> div.body {padding-left:30px;} h2,h3 {margin-left:-30px;} </style></h2>
<p>Scriptonit is a tool that you can use to create a Windows EXE with all the
skills you already have from web programming.  That is, if you know what
HTML is and you speak some Javascript, you'll have no problems to implement
whatever's in your mind and it will all look like a standard exe
application.  Behind the scenes it will run in a browser (Edge) but noone
will actually realize that if you don't want them to.  Your window will
look like any other OS-created window; you can even minimize or resize it
programmatically. You can run shell commands and capture their output,
access the local filesystem, interact with the user, display the progress
of something running in the background, etc - and all you have to do is
write a few lines of JS code.  Scriptonit will take care of the rest.</p>
<h3>Hello World</h3>
<p>There is an example program called Hello World.  With this, you can easily
understand the anatomy of a Scriptonit application:</p>
<pre><code class="language-txt">hello.exe
assets/start.html</code></pre>
<p>This is the bare minimum.  The name of the folder &quot;assets&quot; is fixed; also
the name of the file to be loaded first: <em>start.html</em> - and it should be
in <em>assets</em>.  That's all you need for such a simple task.  Let's see how
the HTML looks:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv="content-type" content="text/html; charset=utf-8" /&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=EDGE" /&gt;
    &lt;title&gt; Your first app! &lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    Hello World!

&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>As you can see, there's nothing special here, other than the second <em>meta</em>
tag; this is required for Edge to actually behave like Edge, not some
stupid Internet Explorer. Apart from this, everything is pretty
straightforward if you've ever worked with HTML.</p>
<p>Later, the <em>&lt;title&gt;</em> tag will become your application window's title;
in a while we'll see how that works.  But first, let's set the title
another way - and for this, we'll need the JS library called the
Scriptonit engine.</p>
<h3>Scriptonit Engine</h3>
<p>Let's add one line before the closing line of the body:</p>
<pre><code class="language-html">&lt;script src="Scriptonit.Engine.js"&gt;&lt;/script&gt;</code></pre>
<p>So now the body looks like:</p>
<pre><code class="language-html">&lt;body&gt;

    Hello World!

    &lt;script src="Scriptonit.Engine.js"&gt;&lt;/script&gt;
&lt;/body&gt;</code></pre>
<p>Now we have the functions ready to use but we're not actually using them;
so it's time to start some Javascript coding.  For this, we add another
line:</p>
<pre><code class="language-html">&lt;body&gt;

    Hello World!

    &lt;script src="Scriptonit.Engine.js"&gt;&lt;/script&gt;
    &lt;script src="start.js"&gt;&lt;/script&gt;
&lt;/body&gt;</code></pre>
<p>...and of course we must add the file <em>assets/Scriptonit.Engine.js</em> to the
project.  But usually it's already there.
Now let's create a <em>start.js</em> from scratch (in <em>assets</em> folder, like
everything else):</p>
<pre><code class="language-js">var sci = new ScriptonitInterface();    // create an instance
sci.window.setTitle("Hey check out my first app!");</code></pre>
<p>That was easy:</p>
<img src='cached.5360f624ad355691e47f78855cd86352.png'>
<p>Now we have the window title under control.</p>
<h3>Automatic reloading</h3>
<p>Leave your application running now, and try to edit the window title in
the Javascript file!  As you can see, your running exe file monitors the
source folder so your title <em>instantly changes as you modify the source</em>.
How cool, isn't it?  This is called the <em>Auto-reload</em> feature.  You can
turn this off if it's annoying - just right click anywhere on your window
and flip the switch:</p>
<img src='cached.7204538d2273ffe5fb72a576752c17b2.png' class="plain">
<p>As you can see there are hotkeys for everything.  (If your application
wants to use these hotkeys for something else, they can be turned off,
more on that later.)  F2 is quite simple, it's for manual reloading; F5
also works because you're inside a browser.</p>
<h3>Stylesheet</h3>
<p>Let's add a stylesheet now!  Scriptonit supports LESS and CSS stylesheets,
so if you only know CSS you won't get into trouble - just start doing what
you'd normally do, add the &lt;link&gt; tag in the head section of your html
file:</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;meta http-equiv="content-type" content="text/html; charset=utf-8" /&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=EDGE" /&gt;
    &lt;link rel="stylesheet" href="start.css"&gt;
    &lt;title&gt; Your first app! &lt;/title&gt;
&lt;/head&gt;</code></pre>
<p>And now you can style the hell out of your contents:</p>
<pre><code class="language-css">body {
    padding: 30px 40px;
    font: 20px arial;
    color: steelblue;
}</code></pre>
<img src='cached.de8aeda8a86549856dd8279da97adb76.png'>
<p>A lot more attractive, right?...  Now if you prefer LESS, all you have to
do is rename your file <em>start.less</em> and include <em>less2css.exe</em> in the
project.  (It's also there by default.)  This compiler automatically
translates our <em>something.less</em> file into a <em>something.less.css</em>, so
we should now modify the start.html link tag too:</p>
<pre><code class="language-html">&lt;link rel="stylesheet" href="start.less.css"&gt;</code></pre>
<p>It's IMPORTANT to know that the less-to-css transformation only happens
automatically when <em>the application is running AND you change the .less
file</em>.  This is very convenient but also a bit confusing for the first
time - so if you don't see your styles right away, leave the app running
and change something in start.less!  (An empty line will do nicely.)  It
should be refreshed now; and there's a new file called <em>start.less.css</em>
which is freshly created by <em>less2css.exe</em>.  You won't have to worry about
these guys anymore, just focus on start.less and everything else happens
like magic.</p>
<h3>How a normal project looks</h3>
<p>Now that we have a few more files, let's see what a typical Scriptonit
project looks like:</p>
<pre><code class="language-txt">assets/...

    less2css.exe                LESS to CSS compiler
    Scriptonit.Engine.js        The Scriptonit Interface
    Scriptonit.Helpers.js       Some helper functions
    start.html                  Your little autoexec :)
    start.js                    You know this one, we've just created it
    start.less                  Also a familiar guy
    start.less.css              Generated from start.less</code></pre>
<p>It will always be like this: one single exe file in the main folder and
a lot of good stuff under <em>assets</em>.  So now that we have a Scriptonit
engine and the helpers, let's use their power!</p>
<h3>Scriptonit capabilities</h3>
<p>Let's keep up with the convention that <em>sci</em> is our Scriptonit Interface
object! Now we have the following groups of commands (technically,
smaller objects inside sci):</p>
<pre><code class="language-js">sci.window          Deal with the application window
sci.file            Access the filesystem, load/save/etc
sci.shell           Run shell (MSDOS) commands, capture their output
sci.dialog          Use standard Windows dialogs (not yet supported!)</code></pre>
<h3>Window methods</h3>
<p>You have some basic methods to manipulate your application window:</p>
<pre><code class="language-js">sci.window.setTitle(text)       // Set window title (you know this)
sci.window.minimize()           // Minimize window
sci.window.maximize()           // Maximize window
sci.window.restore()            // Set normal window 
sci.window.setLeft(x)           // Set window left edge, relative to screen
sci.window.setTop(y)                // Set window top edge, relative to screen
sci.window.setWidth(w)          // Set window outer width in pixels
sci.window.setHeight(h)         // Set window outer height in pixels
sci.window.getLeft()            // Get left edge
sci.window.getTop()             // Get top edge
sci.window.getWidth()           // Get outer width
sci.window.getHeight()          // Get outer height</code></pre>
<h3>File methods</h3>
<p>You can access the filesystem using the <em>sci.file.xxxx</em> methods; these
are mapped to native .NET calls so it's all pretty fast. Still, it's not
recommended to work with huge (&gt;1GB) files for performance reasons; file
interface has no proper file open/seek/read mechanism at the moment so
all you can do is read a whole file or write it all back. </p>
<pre><code class="language-js">sci.file.load(name)         // Read the contents of a file into a string
sci.file.save(name,text)    // Write a string into a file
sci.file.exists(name)       // Returns if the file is there (true/false)</code></pre>
<h3>Shell methods</h3>
<p>Shell interface gives you an easy way to run MSDOS commands; either as a
<em>short command</em> which will run fully and return a string result, or (for
longer processes) a background thread that you can actively monitor via
callbacks.  For these two very different approaches you have two methods:</p>
<pre><code class="language-js">sci.shell.shortCommand(cmd)     // Run command, wait for exit, return output
sci.shell.capture(cmd,f1,f2)    // Start background command with callback functions</code></pre>
<p>Capture works with 2 callbacks: one for ongoing reads, called periodically
during waiting for the command to end; the other is called <em>after</em> it's
all done and the results are final. Both callbacks should have a string
parameter, the ongoing one will be called with the difference since the
last call (arrived lines) and the final callback will get the whole string.</p>
<p>sci.shell.shortCommand, on the other hand, will simply return the whole
result, no callbacks, no waiting, no nothing.  Be careful though: it's up
to you to ensure that the command will not run for a long time, like many
seconds for example. Scriptonit will do nothing else while waiting, so make
it as short as possible.</p> </div>

        
</div>
</body>
<script src='innote.highlight.js'></script>
<script> hljs.highlightAll(); </script>
</html>